mysql数据库锁（innodb 引擎）：
    1. 读锁和写锁，也叫共享锁和排他锁。 共享锁：可同时读，读的时候，不可update，delete。平时select的时候是不加任何锁的
    在select的过程中，任何crud操作都允许执行。可以通过select ..lock in share mode 为select 添加共享锁，这时，可以避
    面更新操作的并行执行。排他锁可以通过  select.. for update 添加，平时的update，delete 操作会自动更新条件下的记录获得排他锁的。
    (这一点很重要),只是对更新操作下where 条件的记录锁定(在有索引的存在下,如果不存在索引,innodb 会锁定全表),
    乐观锁因为有额外的where条件列,所以如果不满足条件的话,不会对记录加锁.

    2. 乐观锁：应该算是应用程序里面的概念，是一种逻辑锁，不是数据库本身提供的。具体实现其实就是为可能会发生竞争的数据表加上一列
    （通常为version 或者时间戳），在update的时候，先查一下老的版本号，以这个老的版本号作为更新条件，追加到where 条件后面，并
    且，重新设置新的版本号（update xx set version = version+1 where version=#{oldVersion}）如果update操作失败说明
    这条记录的版本号之前有被别的线程改过.从而避免并发情况下不一致的问题。
        2.1 乐观锁锁定的是资源对象本身，局限性大.
        2.2 举个例子避免忘记: 比如减少积分操作,先查一下原来积分,在更新的时候追加该条件
            伪码:
                for (;;) {
                            int version = select 当前的版本号
                            if (update(带版本号条件的sql) > 0) {
                                return '更新成功'
                            }
    3. ABA问题：                  }
本来结果为A中间做了一次update操作，然后又将状态恢复到A的状态，这样对于其他人来说，他是不知道A发生过修改操作的

    4. 行锁实现所要注意的点:refer from:http://book.51cto.com/art/200803/68127.htm
        4.1: 行锁锁定的是条件列索引所限定的记录,如果其他查询也涉及到这些记录,更新操作也会等待,即使使用不同的条件列
        4.2: 行锁针对索引键和索引条件所涉及的行,相同索引键的两个for update 操作,即使根据条件涉及的记录不同,两个for update 操作也会阻塞
 mysql,MyISAM:
    1. myISAM 引擎有两种锁模式, 读锁和写锁.两种模式都是锁定全表.读锁可以并发读取,不允许更新操作.写锁,所有操作都是串行执行