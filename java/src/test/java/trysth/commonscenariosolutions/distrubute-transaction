利用消息队列保证分布式事务的流程总结:
	refer from: https://juejin.im/post/5aa3c7736fb9a028bb189bca

	1. 生产者开始处理事务调用时向消息队列发送一则消息，说我要开始执行事务调用了，消息中间件持久化这个消息
	2. 然后生产者开始执行本地的业务方法调用，成功执行完本地操作后向消息中间件发送一条commit指令
	消息中间件收到commit后，将消息发送到消费者消费，消费方执行完了以后也发一个commit到消息中间件，这样一个分布调用结束

	3. 2的过程中指的都是理想的情况，下面对于每个节点说一说，消息中间件和消费端是如何保证事务的最终一致性的
			3.1 生产者发送完 ”我要执行事务操作"的指令给mq后，如果没有成功执行本地调用，或者执行完未成功提交commit给mq
			超时时间过后，mq会主动访问生产者，问”你的方法到底有没有执行完啊，有的话给我个commit答复啊"，接口返回3中情况
				a. 如果返回已提交，则mq分发消息到消费端
				b. 如果返回回滚， 则直接将这条消息丢弃,这样消费端就消费不了了。
				c. 如果返回处理中，则继续等待
			
			3.2 那mq又如何保证消息一定能被消费掉的呢？
				答案：mq如果没有收到消费者成功消费的信号，会重试重新发送给消费端，这也叫最大努力通知。
				这里需要注意的是，消费端代码需要确保消费的幂等性。

				那如果消费端代码本来就有问题，肯定消费不掉，这个时候mq应该怎么处理？答案是，mq不做处理
				消费不掉是你消费端的事，但mq会维护没有成功消费掉的消息列表。需要消费者主动拉取消息，重新消费
	
				




