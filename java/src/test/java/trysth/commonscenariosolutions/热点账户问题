refer from:
问题提出:
单一账户高并发增加,减少金额

解决办法:
    1. 设计层面:
        对于加钱操作,只记流水,定时sum,缺点就是余额更新不实时
        对于减钱操作,将一个账户拆分成多个子账户,前置hash,减少并发度,缺点就是总的金额可能是够的,但子账户的金额确实不够的.造成减钱不成功
    2. 技术层面:
        2.1: 乐观锁:
            核心思想:假设没有并发冲突,去完成某项操作,冲突的话,就重试. 适用于并发冲突不是很激烈的情况
            cas 是乐观锁的一种实现思路:
                核心思想:共有3个变量,一个当前的值,一个是期望的值,一个是需要更新的值
                if  当前值 == 期望值  then  do update 操作
            借鉴于cas的思想,数据库层面可以通过添加一个附加字段的形式, 通过 compare and set 这个额外字段来实现
            update xx set version = version +1 ,column = xx where version = #{version} and condColumn = #{condColumn}
            特别注意: where 条件列  设置索引
        2.2: 分布式锁:
            redis实现: 利用redis的setNx命令,事务执行完毕后删除key
        2.3: 队列:
            前置队列消峰,减少后端并发度.





        
