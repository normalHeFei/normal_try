### 网络基础：
   网络7层模型主要的4层:  应用层(telnet,ftp) > 传输层(udp/tcp) > 网络层(ip,icmp) > 数据链路层(arp(ip 与 mac 地址映射))
   从上往下的过程都会加上上次协议的协议头.最终到数据链路层的协议格式应该是这样的 应用层协议头-传输层协议头-网络层协议头-数据内容
   传输的数据大小最小为46位,最大为1500位.采用缺少就补,多的话就拆包的原则. 
   
数据链路层： 
链路层包的格式主要有两个规范，ieee 8023 和 以太网。
mtu （最大传输单元），针对与路由器才有的东西。链路层协议不仅本身针对于大的帧（链路层上数据的传输单元叫做帧）有拆分，对于在传输的链路上的每个路由器也有一个 最大传输单元的概念，帧的大小超过了路由器的最大传输单元的话，也会被拆包 
arp: 用于根据ip 获取 物理mac地址
网络层：
ip： ip协议是不可靠，主要完成的任务就是路由寻址
icmp 差错报文： ping 应用就是使用该协议。用于测试是否可达的场景？  
ip 协议的报文格式：  //todo 

传输层:
tcp: 由于网络层ip协议是不稳定的,比如掉包,并且数据包过大,网络层会进行分片,所以tcp要处理诸如掉包,数据流组合等工作.说tcp是基于数据流的也是这层意思 
tcp连接终止为何要经过4次握手?
tcp 是一个全双工的协议,所谓全双工,就是指两边都维护连接状态,a 到 b 发送fin 信号, b 发送 ack  fin 信号回给a,这两次握手只是断掉了a到b的连接,如果要断掉 b到a的连接,同样的握手过程需要再从b到a 再进行一遍

utp:不稳定的,应用层包有多大就传多大,加上自己的头部就给ip层. 是基于数据报的.指的就是这层意思

tcp细节 及 选项
窗口大小: 接收方最大能够接受的未确定的数据大小,用于流量控制



几个系统自带的直接利用网络层差错协议icmp的网络应用程序
1. ping  
2. traceroute 
两者都是根据icmp 差错报文协议来确定网络是否可达 

注：
不过是那层协议的报文，最后都是协议头都是叠加到头部在链路层统一发送的。 
### 一些概念：
* 掩码： 粗浅的认识，可以理解为用于隐蔽真实数值的计算因子。 掩码掩码就是掩盖的意思。 
* 子网掩码：子网掩码的主要功能是告知网络设备，一个特定的IP地址的哪一部分是包含网络地址与子网地址，哪一部分是主机地址。网络的路由设备只要识别出目的地址的网络号与子网号即可作出路由寻址决策，IP地址的主机部分不参与路由器的路由寻址操作，只用于在网段中唯一标识一个网络设备的接口。简单而言，子网掩码的功能主要是为了确定一个ip，它是属于哪个网络的。
* 一些网络文档中提到的编码一词的含义，如数据编码的含义，其实就是指数据是怎么组织的含义。 
### websocket：
*  建立链接的第一步是发送一个http get 请求，请求中增加upgrade 字段，标识协议升级为websocket 协议。 接下来的过程就是通过websocket 协议来进行通信
* 协议大致包含一个几个标识位： fin（true/false）用于标识是否接收完毕;opCode（text/binary） 用于标识消息的类型，文本消息还是二进制消息？;masking-key： 掩码魔数; payload： 消息载体
* 网络地址转换（NAT），常见的NAT设备就是路由器之类的东西。主要起到转换ip地址的作用。网络框架定期发送心跳报的目的是为了让NAT的转换地址列表（真实ip -> 转换ip）不要超时。


### 开源实现框架：
   
Netty:  
利用netty编写nio程序的大体流程：
1.实例化Bootstrap
2.向channelPipeline 中添加 合适的handler
3.自定义协议， 涉及到协议的指定，以及消息的编码和解码
几个重要的api：
1.byteBuf： 字节流的封装对象，nio 的 ByteBuffer使用，容易出错。需要flip什么，又分读写模式，且读写模式需要切换
2.channelIniter： 也是channelHandler 的一种 
3.EventLoop：  负责多个channel的事件处理，同时也是一个线程 
4.ChannelPipeline： channelHandler 的调用链？ 
5.channelHandler： 分为 inboundHandler 和 outboundHandler，inbound 的处理顺序是由前往后，outbound的处理顺序由后往前。 
6.ChannelHandlerContext： 一个 channelHandler 绑定一个 context


不得不提的reactor 模型：

1. reactor 模型是一个非阻塞的异步模型。（即应用程序不必傻傻等待io资源准备好，可以自己干其他事，这一点描述的是非阻塞;而异步其实指的就是在非阻塞的基础上，当操作系统io资源准备好的情况下，可以通过事件回调的机制来通知你应用程序，这样相比于应用程序定时轮询的方法来获得io资源准备情况要好的多。注：异步不异步，常常伴随着事件通知）

2. 关于reactor 的三种模型，参考与 https://crossoverjie.top/2018/05/24/netty/Netty(1)TCP-Heartbeat/

使用socket.io 实现 im 的大致步骤及考虑的点：

1. socket.io 是定位聊天场景的自定义协议。对于支持websocket协议的 client(如主流版本的浏览器)采用websocket 协议通信，对于不支持的client 采用长轮询的方式实现。因为定位与聊天场景，协议本身又添加了诸如，会话重连，namespace， 房间号的概念

2. 代码层面： 
透过解码与编码来判断socket.io 的协议格式：
报文格式： 

买卖家聊天模块 todo List：

1. 买卖家聊天状态维护
2. 一次聊天请求的具体流程            
3. websocket 是怎么实现双向通信的？  长连接 
4. 
