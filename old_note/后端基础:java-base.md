### 并发多线程 
1. notify & notifyAll & wait   
3个方法执行都需要获得同步块的锁对象，所谓“获得锁对象” 其实就是指要在同步块中执行。
线程执行到wait 方法时就会，释放 同步锁，其他线程可以进入到同步块
线程执行 notify & notifyAll 方法其实只是其他wait线程能够执行同步块的条件之一， 只有当线程a调用notyAll 方法 并且 执行完同步块中的代码以后，wait 状态的线程才能够继续执行 。   
2. 关于java 中的中断    
2.1 wait，sleep等方法抛出中断异常后，虽然客户端代码显示的调用过thread.interrupt方法，但抛出异常侯，线程中断状态会重新被恢复成未中断(false),即调用thread.isInterrupted()还是返回false; 代码见 TestInterrupt 的StopByInterruptTask 测试用例 
2.2  java中的中断是基于状态的，并不是强制性的，中断可以理解为中断者和被中断者的一种交互协议。 

### GC & jvm & classloader
1. 目前主要搭配的GC组合是，ParNew（年轻代） + CMS（老年代），所以针对与这种组合说明：
a. 年轻代主要采用复制回收算法，即内存空间分为两半，一部分用来存储对象，另一部分用于存放回收后仍然存活的对象。基于这种思想，年轻代分为eden （1个）+ Survivor（2两个）; 老年代才用标记-清除算法，这也是cms GC采用的回收思路;
b. 分析的思路： 是要吞吐量（cpu执行程序的时间占总时间比例： 程序执行时间+gc时间/总时间，停顿时间长， 但能提高cpu的利用率。适用于后台任务程序，用户无感知的情况）还是响应速度（停顿时间小，强调用户交互的情况）？ 分析前明确是要提高的是那一个指标？ 再根据jvm日志调整参数

2. classLoader
分为 bootstrap classLoader<Ext ClassLoader<SystemClassLoader
采用委托的方式加载类（即先尝试使用parentClassLoader 加载如果加载不了的话，就用自己的classLoader加载）
由于采用这种委托的方式，如果有 父加载器要加载 子加载器的类的需求的话（如tomcat 要加载额外的包）就无法满足需求，因为父加载器永远加载不了子加载器才能加载的类，只能通过子类加载器才能加载。 这个时候就可以通过类似于 “线程变量” 的方式来实现，及在 父加载器需要加载子类class的时候，将子类加载器 设置在“线程变量”中，在父加载器中，从线程变量中获取子类加载器。 这种方式就是 Thread.getContextClassLoader 获取线程上下文类加载器。

### 数据结构
HashMap  
1.大致实现流程: key做hash,hash完找到对应的index,放入数组, 如果key相同,即存在hash冲突的话,以列表的形式存储,将新的元素插入到列表的头部, 如果列表的长度大于阀值,则将列表进行转换,转换成红黑树, 这是java8中的实现,转化的目的是为了可以再hash冲突比较大的情况下,保证O(log n)的搜索效率. 此外桶数组的大小也是会进行扩展的, 如果容量大于阀值(即桶数组大小 * 负载因子),则数组容量会变成原来的两倍, 原先存储在每个列表中的entry 也会进行 rehash     
2. 关于hash 方法的说明：    
找对应hash 数组的index的时候： （lenght -1） & hashCode 等价与对lenght 取模， 直接取模，冲突较大， 运用 高位异或分散hash 值 。 参考： https://www.zhihu.com/question/20733617   
2.java 8 中做的优化.   
列表长度过大的时候,会转化成红黑树, 时间复杂度 有 O(n) -> O(log n )
rehash 采用高位运算,原有entry hash 后的index要么不动,要么在i+size/2 的位置. 而java7中则是重新进行hash

### 其他 
1. 静态块，静态成员变量， 普通语句块，实例变量， 构造方法。 静态块，用于在类初始话时主动加载一些初始话信息，且执行一边，静态代码块和静态成员变量的执行顺序取决与代码书写的前后， 同理， 普通语句块和实例变量也是一样    

2. 原码 & 反码 & 补码  
原码即为正常二进制怎么存储的.
反码即每位取反
补码即在反码的基础上加1
需要注意的是对于负数, 第一位是符号位,符号位不受取反影响

这里以 5,-5 的二进制作为例子:
十进制 原码 反码 补码

5  0000 0101 1111 1010 1111 1011   
-5 1000 0101 1111 1010 1111 1011

3. 关于逻辑移位 & 算术移位

逻辑移位: 左移,左移后,右位用0补充, 右移左边的用0补齐. 这样对于负数的话,就会变为正数  

算术移位: 移动过程中,符号位不受移位影响原来是什么就是什么. 例如1000 0101 右移一位就变为 1100 0010  

关于移位: 二进制存储时,最左端为符号位,正数为0,负数为1, 左移不管符号位,即符号位也会被右边的给顶掉,左移过程中右边空出来的用0补齐, 
每移一位就相当于 乘以 2 的 n(移动位数) 倍.而右移是最左边的符号位不变,右移的过程左边多出来的位,如果符号位是0就用0填充,如果符号位是1就用1填充  

应用
正数x左移y位, 等于 x^y, 如 3<<1 == 9
正数x右移y位 等于 (x-1)/2 3>>1 == 1

参考:
http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html
https://edwardluo.wordpress.com/2015/04/08/%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D%E5%92%8C%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/
https://blog.yangx.site/2016/07/06/bit-operation-skills/